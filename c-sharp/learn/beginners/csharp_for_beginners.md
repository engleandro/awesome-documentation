# C# FOR BEGINEERS

# LEARN: C# (C-Sharp)

* C# (C-Sharp) is an object-oriented programming language developed by Microsoft that runs on the .NET Framework.
* C# has roots from the C family, very similar to C++ and Java.
* Last C# 11 was released in November 2022.

---

# Install & Configure C# on Windows

## Install Visual Studio Code

Download and install Visual Studio Code from the official website.

## Install C# Extension

Open Visual Studio Code and press Ctrl+Shift+X to open the Extensions tab.
Search for C# and install the extension.

## Install .NET Core SDK

Download and install .NET Core SDK from the official website.

# Configure C# on Visual Studio Code on Windows

## Create a new project

Open Visual Studio Code and press Ctrl+Shift+P to open the Command Palette.

Type "dotnet" and select "C#: Create New Project".

Select "Console Application" and press Enter.

---

# Create a first project

Start a project with the command line:

```powershell
cd "to\your\project\folder"
dotnet help
dotnet new --list
dotnet new console
dotnet build # not necessary
dotnet run
```

hello-world.cs

```csharp
using System; // import classes from the System namespace (container for classes and other namespaces)

namespace MyNamespace // create a namespace
{
  class MyClass  // create a class?: a container for data and methods
  { // marks the beginning of a block of code
    public static void Main(string[] args) { // create a public static method that receives a string as a parameter and returns nothing
      Console.WriteLine("Hello World!");  // write text to the console. Console is a class from the System namespace for console input and output
    }
  } // marks the end of a block of code
}
```

---

# C# Syntax

## General Syntax

* C# is a compiled language
* C# is a strongly typed language
* C# is an object-oriented programming language, so it is based on namespaces, classes, objects, methods, properties, and events
* C# uses indentation to define code blocks
* C# uses semicolons (;) to separate statements
* C# ignores white space and empty lines
* Curly braces {} marks the beginning and the end of a block of code
* C# uses Unicode (UTF-16)
* C# is case-sensitive
* C# files have an extension of `.cs`

## Write-Method
  
```csharp
System.Console.WriteLine("Hello World!");
System.Console.Write("Hello World without line break!");
```

## Comments

```csharp
// This is a single line comment
Console.WriteLine("Hello World!"); // This is a single line comment at the end of a line of code

/* This is a
multi-line
comment
*/
```

## Variables

Variables are containers for storing data values.

```csharp
// syntax: type variableName = value; or type variableName;
int myNum;                   // Integer (whole number); without assignment
myNum = 1;                  // assign value 1 to myNum
myNum = 10;                 // reassign value 10 to myNum
double myDoubleNum = 5.99D;   // Float (double, 64bits) point number
float myFloatNum = 5.99F;     // Floati (float 32 bits, 7 decimal points) point number
char myLetter = 'D';         // Character: Char values are surrounded by single quotes
string myText = "Hello";     // String: String values are surrounded by double quotes
bool myBool = true;          // Boolean (true or false)
```

Multiple variables of the same type can be declared on the same line:

```csharp
int x = 5, y = 6, z = 50;
int i, j, k;
i = j = k = 5;
Console.WriteLine(x+y+z); // Outputs 15
```

# Constants

Constants are variables that cannot be changed.

```csharp
const float pi = 3.1415926F;
const double PI = 3.14159265358979323846D;
```

## Display Variables

```csharp
int myNum = 5;
string myString = "Hello";
string name = "John";
string myText = myString + " " + name; // Outputs Hello John
Console.WriteLine(myNum); // Outputs 5
Console.WriteLine(myString); // Outputs Hello
Console.WriteLine(myNum + myString); // Outputs "5Hello"
Console.WriteLine(myText); // Outputs "Hello John"
```

## Identifiers

Identifiers are names given to entities like namespace, class, variables, methods, properties, and so on.

* identifiers must be unique
* identifiers can contain letters, digits, and the underscore character (_)
* identifiers cannot start with a digit
* identifiers are case-sensitive (age, Age and AGE are three different identifiers)
* identifiers cannot contain white space
* identifiers cannot contain special characters like !, @, #, $, %, etc.
* identifiers cannot be a C# keyword or reserved word

C# reserved words:

```
# generated by Copilot

abstract	as	base	bool	break	byte
case	catch	char	checked	class	const
continue	decimal	default	delegate	do	double
else	enum	event	explicit	extern	false
finally	fixed	float	for	foreach	goto
if	implicit	in	int	interface	internal
is	lock	long	namespace	new	null
object	operator	out	override	params
private	protected	public	readonly	ref
return	sbyte	sealed	short	sizeof	stackalloc
static	string	struct	switch	this	throw
true	try	typeof	uint	ulong	unchecked
unsafe	ushort	using	virtual	void	volatile
while
```

## Data Types

C# is a strongly typed language, which means that every variable has a specific type, and that type cannot be changed.

A data type specifies the size and type of variable values. A type can be a built-in type or a user-defined type. A type is a class or a struct.

### Primitive Data Types

signed: positive and negative numbers
* sbyte: stores whole numbers from -128 to 127
* short: stores whole numbers from -32,768 to 32,767
* int: stores whole numbers from -2,147,483,648 to 2,147,483,647
* long: stores whole numbers from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807

unsigned: positive numbers only
* byte: stores whole numbers from 0 to 255
* ushort: stores whole numbers from 0 to 65,535
* uint: stores whole numbers from 0 to 4,294,967,295
* ulong: stores whole numbers from 0 to 18,446,744,073,709,551,615

Floating point types:
* float: stores fractional numbers. Sufficient for storing 6 to 7 decimal digits

```csharp
float myNum = 5.75F;
```

* double: stores fractional numbers. Sufficient for storing 15 decimal digits

```csharp
double myNum = 19.99D;
```

* decimal: stores fractional numbers. Sufficient for storing 28-29 decimal digits
* bool: stores true or false values

```csharp
bool isCSharpFun = true;
bool isFishTasty = false;

Console.WriteLine(isCSharpFun);   // Outputs True
Console.WriteLine(isFishTasty);   // Outputs False
```

* char: stores a single character/letter or ASCII values; surrounded by single quotes

```csharp
char myGrade = 'B';
char a = 'a';
char[] myCharArray = { 'a', 'b', 'c', 'd', 'e' };
```

### Non-Primitive Data Types

* string: stores a sequence of characters

```csharp
string greeting = "Hello World!";
```

* array: stores a fixed-size sequential collection of elements of the same type

```csharp
string[] cars = new string[4] {"Volvo", "BMW", "Ford", "Mazda"};

foreach (string i in cars)
{
    Console.WriteLine(i);
}
```
* List: stores a list of elements of the same type

```csharp
List<string> cars = new List<string>() { "Ford", "Mazda" };
cars.Add("Volvo");
cars.Add("BMW");

foreach (string i in cars)
{
    Console.WriteLine(i);
}
```

* enum: stores a set of constants
* class: stores data and methods
* interface: stores only method signatures
* struct: stores data and methods
* delegate: stores references to methods with a particular parameter list and return type
* Dictionary: stores a collection of key/value pairs

```csharp	
Dictionary<string, string> myDict = new Dictionary<string, string>();
myDict.Add("key1", "value1");
myDict.Add("key2", "value2");
myDict.Add("key3", "value3");

foreach (KeyValuePair<string, string> item in myDict)
{
    Console.WriteLine(item.Key + " " + item.Value);
}
```

## Operators

Operators are used to perform operations on variables and values.

### Arithmetic Operators

| Operator | Name | Example |
| --- | --- | --- |
| + | Addition | x + y |
| - | Subtraction | x - y |
| * | Multiplication | x * y |
| / | Division | x / y |
| % | Modulus | x % y |
| ++ | Increment | ++x |
| -- | Decrement | --x |

```csharp
# scientific notation
double d1 = 35e3;
double d2 = 12E4;
float f1 = 12E4F;
Console.WriteLine(d1); // Outputs 35000
Console.WriteLine(d2); // Outputs 120000
Console.WriteLine(f1); // Outputs 120000
```

### Assignment Operators

| Operator | Example | Same As |
| --- | --- | --- |
| = | x = 5 | x = 5 |
| += | x += 3 | x = x + 3 |
| -= | x -= 3 | x = x - 3 |
| *= | x *= 3 | x = x * 3 |
| /= | x /= 3 | x = x / 3 |
| %= | x %= 3 | x = x % 3 |
| &= | x &= 3 | x = x & 3 |
| ^= | x ^= 3 | x = x ^ 3 |
| |= | x |= 3 | x = x \| 3 |
| <<= | x <<= 3 | x = x << 3 |
| >>= | x >>= 3 | x = x >> 3 |

### Comparison Operators

| Operator | Name | Example |
| --- | --- | --- |
| == | Equal to | x == y |
| != | Not equal | x != y |
| > | Greater than | x > y |
| < | Less than | x < y |
| >= | Greater than or equal to | x >= y |
| <= | Less than or equal to | x <= y |

### Logical Operators

| Operator | Description | Example |
| --- | --- | --- |
| && | Returns true if both statements are true | x < 5 &&  x < 10 |
| \|\| | Returns true if one of the statements is true | x < 5 \|\| x < 4 |
| ! | Reverse the result, returns false if the result is true | !(x < 5 && x < 10) |

```csharp
bool isTrue = true;
bool isFalse = false;
Console.WriteLine(isTrue && isFalse); // Outputs False
Console.WriteLine(isTrue || isFalse); // Outputs True
Console.WriteLine(!isFalse);          // Outputs True
```

### Bitwise Operators

| Operator | Name | Description |
| --- | --- | --- |
| & | AND | Sets each bit to 1 if both bits are 1 |
| \| | OR | Sets each bit to 1 if one of two bits is 1 |
| ^ | XOR | Sets each bit to 1 if only one of two bits is 1 |
| ~ | NOT | Inverts all the bits |
| << | Zero fill left shift | Shift left by pushing zeros in from the right and let the leftmost bits fall off |
| >> | Signed right shift | Shift right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off |

### Misc Operators

| Operator | Name | Description |
| --- | --- | --- |
| sizeof | Size of | Returns the size of a variable |
| typeof | Type of | Returns the type of a variable |
| & | Address of | Returns the address of a variable |
| * | Pointer to | Returns the value of the variable located at the address specified by a pointer |

```csharp	
int a = 10;
Console.WriteLine("Size of int: {0}", sizeof(int)); // Outputs 4
Console.WriteLine("Type of a: {0}", typeof(a)); // Outputs System.Int32
Console.WriteLine("Address of a: {0}", &a); // Outputs 0000000000000000
CONSOLE.WriteLine("Value of a: {0}", *a); // Outputs 10
```

## Type Casting

Type casting is when you assign a value of one primitive data type to another type.

```csharp
// Implicit Casting (automatically) - converting a smaller type to a larger type size
int myInt = 9;
double myDouble = myInt; // Automatic casting: int to double
// Explicit Casting (manually) - converting a type to another type manually by placing the type in parentheses in front of the value
double myDouble = 9.78;
int myInt = (int) myDouble; // Manual casting: double to int
```

Type conversion can also be done with methods and built-in methods:

```csharp
int myInt = 10;
double myDouble = 5.25;
bool myBool = true;
Console.WriteLine(Convert.ToString(myInt));    // convert int to string
Console.WriteLine(Convert.ToDouble(myInt));    // convert int to double
Console.WriteLine(Convert.ToInt32(myDouble));  // convert double to int
Console.WriteLine(Convert.ToString(myBool));   // convert bool to string
```

## User Input

```csharp
Console.WriteLine("Enter username:");
string username = Console.ReadLine(); // Get user input from the keyboard and return it always as a string
Console.WriteLine("Username is: " + username);
```

## Math Class

```csharp
Console.WriteLine(Math.Max(5, 10)); // Outputs 10 (max of 5 and 10)
Console.WriteLine(Math.Min(5, 10)); // Outputs 5 (min of 5 and 10)
Console.WriteLine(Math.Sqrt(64)); // Outputs 8 (square root of 64)
Console.WriteLine(Math.Abs(-4.7)); // Outputs 4.7 (absolute value of -4.7)
Console.WriteLine(Math.Pow(5, 3)); // Outputs 125 (5 to the power of 3)
Console.WriteLine(Math.Round(9.99)); // Outputs 10 (rounds up)
```

## Strings

```csharp
string hello = "Hello";
string world = "World";
string helloWorld = hello + " " + world;
string greeting = string.Concat(hello, " ", world);
Console.WriteLine(helloWorld); // Outputs Hello World
Console.WriteLine(string.Format("{0} {1}", hello, world)); // Outputs Hello World (using string.Format)
string phrase = "Giraffe Academy";
Console.WriteLine(phrase.Length); // Outputs 15 (length of string)
Console.WriteLine(phrase.ToUpper()); // Outputs GIRAFFE ACADEMY (converts string to uppercase)
Console.WriteLine(phrase.ToLower()); // Outputs giraffe academy (converts string to lowercase)
Console.WriteLine(phrase.Contains("Academy")); // Outputs True (checks if string contains a word)
Console.WriteLine(phrase[0]); // Outputs G (accesses a character in a string)
Console.WriteLine(phrase.IndexOf("Academy")); // Outputs 8 (finds the index of a word)
Console.WriteLine(phrase.Substring(8)); // Outputs Academy (gets a substring from a string)
Console.WriteLine(phrase.Substring(8, 3)); // Outputs Aca (gets a substring from a string)
Console.WriteLine(phrase.Replace("Giraffe", "Elephant")); // Outputs Elephant Academy (replaces a word in a string)
```

String interpolation:

```csharp
string name = "John";
Console.WriteLine($"Hello {name}"); // Outputs Hello John
```

Special characters:

```csharp
string phrase = "Giraffe\nAcademy"; // Outputs Giraffe Academy (new line)
string phrase = "Giraffe\'s Academy \' \" \\ \n \t"; // Outputs Giraffe"Academy (escape character)
```

## Boolean

```csharp
bool isMale = true;
bool isTall = false;
Console.WriteLine(isMale == isTall); // Outputs False (checks if two booleans are equal)
Console.WriteLine(isMale != isTall); // Outputs True (checks if two booleans are not equal)
Console.WriteLine(isMale && isTall); // Outputs False
Console.WriteLine(isMale || isTall); // Outputs True
Console.WriteLine(!isMale); // Outputs False (negates a boolean)
```

## If Statements

```csharp
int myAge = 25;
int votingAge = 18;

if (myAge >= votingAge) 
{
  Console.WriteLine("Old enough to vote!");
} 
else if (myAge > 60 ) 
{
  Console.WriteLine("Too old to vote!");
} 
else
{
  Console.WriteLine("Not old enough to vote.");
}
```

## Terenary Operator

```csharp
// variable = (condition) ? expressionTrue :  expressionFalse;
bool isMale = true;
string answer = (isMale) ? "He said hi." : "She said hi.";
```

## Switch Statements

```csharp
int day = 4;
switch (day) 
{
  case 1:
    Console.WriteLine("Monday");
    break;
  case 2:
    Console.WriteLine("Tuesday");
    break;
  case 3:
    Console.WriteLine("Wednesday");
    break;
  case 4:
    Console.WriteLine("Thursday");
    break;
  case 5:
    Console.WriteLine("Friday");
    break;
  case 6:
    Console.WriteLine("Saturday");
    break;
  case 7:
    Console.WriteLine("Sunday");
    break;
  default:
    Console.WriteLine("Invalid day number");
    break;
}
```

## While Loops

```csharp
int index = 1;
while (index <= 5) 
{
  Console.WriteLine(index);
  index++;
}
```

## For/Foreach Loops

```csharp
for (int i = 1; i <= 5; i++) 
{
  Console.WriteLine(i);
}

int[] luckyNumbers = {4, 8, 15, 16, 23, 42};
foreach (int luckyNumber in luckyNumbers) 
{
  Console.WriteLine(luckyNumber);
}
```

## Break and Continue

```csharp
for (int i = 0; i <= 10; i++) 
{
  if (i < 2) 
  {
    continue;
  }
  else if (i == 4) 
  {
    break;
  }
  else 
  {
    Console.WriteLine(i);
  }
}
// Outputs 2 3
```

## Arrays

```csharp
int[] luckyNumbers = {4, 8, 15, 16, 23, 42};
string[] friends = new string[5];
friends[0] = "Jim";
friends[1] = "Karen";
friends[2] = "Kevin";
Console.WriteLine(friends[0]); // Outputs Jim
Console.WriteLine(friends.Length); // Outputs 5
Console.WriteLine(luckyNumbers[1]); // Outputs 8
Console.WriteLine(luckyNumbers[1] = 900); // Outputs 900
Console.WriteLine(luckyNumbers[1]); // Outputs 900
```

Looping through arrays:

```csharp
int[] luckyNumbers = {4, 8, 15, 16, 23, 42};
for (int i = 0; i < luckyNumbers.Length; i++) 
{
  Console.WriteLine(luckyNumbers[i]);
}
// Outputs 4 8 15 16 23 42
```

Sort arrays:

```csharp
string[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
Array.Sort(cars);
foreach (string i in cars)
{
  Console.WriteLine(i);
}
// Outputs BMW Ford Mazda Volvo
```

Multidimensional arrays:

```csharp
int[,] numberGrid = 
{
  {1, 2},
  {3, 4},
  {5, 6}
};
Console.WriteLine(numberGrid[0, 0]); // Outputs 1
Console.WriteLine(numberGrid[0, 1]); // Outputs 2
Console.WriteLine(numberGrid[1, 0]); // Outputs 3
Console.WriteLine(numberGrid[1, 1]); // Outputs 4
Console.WriteLine(numberGrid[2, 0]); // Outputs 5
Console.WriteLine(numberGrid[2, 1]); // Outputs 6
```

---

# METHODS

A function or a method is a block of code that performs a specific task and can be reused.

```csharp
static void SayHi(string name, int age = 18) 
{
  Console.WriteLine("Hello " + name + ", you are " + age);
}

static int Cube(int num) 
{
  int result = num * num * num;
  return result;
}
```

Data can be passed to methods as an argument. An argument act as a variable inside the method.
The keyword `static` means that the method belongs to the Program class and not an object of the Program class.
The keyword `void` means that the method does not have a return value.
In C#, it is good practice to start with an uppercase letter when naming methods.
A parameter with a default value is an "optional parameter".

### Method Overloading

method overloading: multiple methods can have the same name with different parameters

```csharp
static int Add(int num1, int num2) 
{
  return num1 + num2;
}
static float Add(float num1, float num2) 
{
  return num1 + num2;
}
static double Add(double num1, double num2, double num3=0.0) 
{
  return num1 + num2 + num3;
}
```

Multiple methods can have the same name as long as the number and/or type of parameters are different.

---

## OOP

Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which can contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods.

Fundamental concepts of OOP:
* Encapsulation
* Abstraction
* Inheritance
* Polymorphism

# CLASSES

Classes and objects are the two main aspects of object-oriented programming.

A class is a template for objects and an object is an instance based on a class. An object is created by instancing a class, it inherits the variables and methods from the class.

## Create a Class

```csharp
class Car // style guide: use PascalCase
{
  public string color = "red"; // field or attribute; style guide: use camelCase

  public static void Drive() // method; style guide: use PascalCase
  {
    Console.WriteLine("vrum...");
  }
}
```

## Create an Object

An object is created from a class. The dot syntax (.) to access attributes/methods inside a class (object.attribute or object.method).

```csharp
Car myObj = new Car();
myObj.color = "red";
myObj.Drive();
```

## Class Members

Fields/attributes and methods inside classes are class members.

```csharp	
class Car 
{
  public string color = "red"; // field or attribute
  protected string model = "Mustang";
  private string id = "431757868568";

  public void MyMethod() // not static
  {
    Console.WriteLine("it is a method");
  }

  public static void MyStaticMethod() // static
  {
    Console.WriteLine("it is a static method");
  }
}

Car car = new Car();
car.color = "red";
car.model = "Mustang"; // error
car.id; // error
car.MyMethod(); // no error
car.MyStaticMethod(); // error
```

## Constructors

A constructor is a special method that is used to initialize objects. The constructor is called when an object of a class is created. It can be used to set initial values for fields/attributes.

```csharp
class Car 
{
  public string color = "red"; // field or attribute

  public Car(string model, int year) // constructor method
  {
    model = model;
    year = year;

    Console.WriteLine("object created");
  }
}
```

Note that the constructor name must match the class name, it cannot have a return type, and constructors can be overloaded.

## Access Modifiers

An access modifier set the access level/visibility for classes, fields, methods and properties. By default, all members of a class are private if you don't specify an access modifier.

| Modifier | Class | Package | Subclass | World | Description |
| --- | --- | --- | --- | --- | --- |
| public | Y | Y | Y | Y | accessible for all classes
| protected | Y | Y | Y | N | accessible within the same class, or in a class that is inherited from that class
| private | Y | N | N | N | only accessible within the same class
| internal | Y | Y | N | N | only accessible within its own assembly, but not from another assembly

There's also two combinations: protected internal and private protected.

## Getters and Setters

Encapsulation makes sure that "sensitive" data is hidden from users:
* declare fields/variables as private
* provide public get and set methods to access and update the value of a private field

```csharp
class Person
{
  private string name; // field/attribute

  public string Name   // property
  {
    get { return name; }   // get method
    set { name = value; }  // set method
  }
}
```

The Name property is associated with the name field. It is a good practice to use the same name for both the property and the private field, but with an uppercase first letter.

The get method returns the value of the variable name.

The set method assigns a value to the name variable. The value keyword represents the value we assign to the property.

An example of using getters and setters:

```csharp
class Person
{
  private string name; // field
  public string Name   // property
  {
    get { return name; }
    set { name = value; }
  }
}

class Program
{
  static void Main(string[] args)
  {
    Person myObj = new Person();
    myObj.Name = "Liam";
    Console.WriteLine(myObj.Name);
  }
}
```

### Auto-implemented Properties

```csharp
class Person
{
  public string Name { get; set; }
}

class Program
{
  static void Main(string[] args)
  {
    Person myObj = new Person();
    myObj.Name = "Liam";
    Console.WriteLine(myObj.Name);
  }
}
```

Why Encapsulation?
* Better control of class members (reduce the possibility of yourself (or others) to mess up the code)
* Fields can be made read-only (if you only use the get method), or write-only (if you only use the set method)
* Flexible: the programmer can change one part of the code without affecting other parts
* Increased security of data

## INHERITANCE

Inheritance is a way to form new classes using classes that have already been defined. The new classes are called derived classes, the classes that are being inherited are called base classes.

Classes on inheritance:
* Derived Class (child) - the class that inherits from another class
* Base Class (parent) - the class being inherited from

To inherit from a class, use the `:` symbol.

```csharp
class Vehicle // base class (parent) 
{
  public string brand = "Ford";
  public void honk()
  {
    Console.WriteLine("Tuut, tuut!");
  }
}

class Car : Vehicle // derived class (child): child : parent
{
  public string modelName = "Mustang";
}
```

### Sealed Keyword

The sealed keyword can be used to prevent inheritance.

```csharp
sealed class Vehicle // base class (parent) 
{
  public string brand = "Ford";
  public void honk()
  {
    Console.WriteLine("Tuut, tuut!");
  }
}

class Car : Vehicle // error
{
  public string modelName = "Mustang";
}
```

## POLYMORPHISM

Polymorphism is the ability of an object to take on many forms. The most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class object.

To override the base class method, by adding the `virtual` keyword to the method inside the base class, and by using the `override` keyword for each derived class methods

```csharp
class Animal  // Base class (parent) 
{
  public virtual void animalSound() 
  {
    Console.WriteLine("The animal makes a sound");
  }
}

class Pig : Animal  // Derived class (child) 
{
  public override void animalSound() 
  {
    Console.WriteLine("The pig says: wee wee");
  }
}
class Dog : Animal  // Derived class (child) 
{
  public override void animalSound() 
  {
    Console.WriteLine("The dog says: bow wow");
  }
}

class Program 
{
  static void Main(string[] args) 
  {
    Animal myAnimal = new Animal();  // Create a Animal object
    Animal myPig = new Pig();  // Create a Pig object
    Animal myDog = new Dog();  // Create a Dog object

    myAnimal.animalSound();
    myPig.animalSound();
    myDog.animalSound();
  }
}
```

## Abstract Classes and Methods

Abstraction is the process of hiding details and providing only essential information to the end-user.

The abstract keyword is used for classes and methods:
* Abstract class: is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class).
* Abstract method: can only be used in an abstract class, and it does not have a body. The body is provided by the derived class (inherited from).

An abstract class can have both abstract and regular methods:

```csharp
abstract class Animal 
{
  public abstract void animalSound(); // abstract method
  public void sleep() // regular method
  {
    Console.WriteLine("Zzz");
  }
}

class Pig : Animal 
{
  public override void animalSound() 
  {
    Console.WriteLine("The pig says: wee wee");
  }
}

class Program 
{
  static void Main(string[] args) 
  {
    // Animal myObj = new Animal(); // Will generate an error (Cannot create an instance of the abstract class or interface 'Animal')
    Pig myPig = new Pig();  // Create a Pig object
    myPig.animalSound();
    myPig.sleep();
  }
}
```

To access the abstract class, it must be inherited from another class.

## Interfaces

An interface is a completely "abstract class" that is used to group related abstract methods and properties; it cannot contain any implementation of methods; it can only contain abstract methods and properties.

By default, members of an interface are abstract and public.

It is a good practice to start with the letter "I" at the beginning of an interface identifier.

```csharp
interface IAnimal 
{
  void animalSound(); // interface method (does not have a body)
  void run(); // interface method (does not have a body)
  //int legs { get; set; } // interface property
  //string color { get; set; } // interface property
  //string name { set; } // interface property: write-only
  //string type { get; } // interface property: read-only
  //int? age { get; set; } // interface property: nullable
}

class Pig : IAnimal 
{
  public void animalSound() 
  {
    Console.WriteLine("The pig says: wee wee");
  }
  public void run() 
  {
    Console.WriteLine("The pig runs: wee wee");
  }
}

class Program 
{
  static void Main(string[] args) 
  {
    Pig myPig = new Pig();  // Create a Pig object
    myPig.animalSound();
    myPig.run();
  }
}
```

To access the interface methods, the interface must be "implemented" by another class.

Some points about interfaces:
* Interfaces cannot be used to instantiate objects.
* Interface methods should be asbstract (no block of code).
* On implementation of an interface, you must override all of its methods.
* Interfaces can contain properties and methods, but not fields/variables;
* Interface members are by default abstract and public
* An interface cannot contain a constructor

Why and when to use interfaces?
* To achieve security - hide certain details and only show the important details of an object (interface).
* C# does not support "multiple inheritance" (a class can only inherit from one base class). However, it can be achieved with interfaces, because the class can implement multiple interfaces. Note: To implement multiple interfaces, separate them with a comma (see example below).

```csharp	
interface IFirstInterface 
{
  void myMethod(); // interface method
}
interface ISecondInterface 
{
  void myOtherMethod(); // interface method
}

class DemoClass : IFirstInterface, ISecondInterface 
{
  public void myMethod() 
  {
    Console.WriteLine("Some text..");
  }
  public void myOtherMethod() 
  {
    Console.WriteLine("Some other text...");
  }
}

class Program 
{
  static void Main(string[] args)
  {
    DemoClass myObj = new DemoClass();
    myObj.myMethod();
    myObj.myOtherMethod();
  }
}
```

## Enumerates

Enumerates are used to define a set of named constants (unchangeable/read-only variables). The values in this set are called the enumerator list.

To create an enumerate, use the `enum` keyword, instead of class or interface.

```csharp
enum Level 
{
  Low,    // 0
  Medium, // 1
  High    // 2
}

class Program 
{
  static void Main(string[] args) 
  {
    Level myVar = Level.Medium;
    Console.WriteLine(myVar); // Medium
  }
}
```

By default, the first value of an enumerate is 0, the second value is 1, and so on. You can change this by assigning a value to the first value.

```csharp
enum Level : int
{
  Low = 1,
  Medium, // 2
  High    // 3
}

enum Months
{
  January,    // 0
  February,   // 1
  March,      // 2
  April,      // 3
  May,        // 4
  June,       // 5
  July        // 6
}

enum StatusCode : short
{
  OK = 200,
  NotFound = 404,
  InternalServerError = 500
}

enum StringEnum : string
{
  OK = "200",
  NotFound = "404",
  InternalServerError = "500"
}

static void Main(string[] args)
{
  int myNum = (int) Months.April;
  Console.WriteLine(myNum); // 3
  float myNum2 = (float) StatusCode.OK;
  Console.WriteLine(myNum2); // 200
}
```

You can also have an enum inside a class.

### Enumerates in a switch statement

```csharp
enum Level 
{
  Low,
  Medium,
  High
}

class Program 
{
  static void Main(string[] args) 
  {
    Level myVar = Level.Medium;
    switch (myVar) 
    {
      case Level.Low:
        Console.WriteLine("Low level");
        break;
      case Level.Medium:
        Console.WriteLine("Medium level");
        break;
      case Level.High:
        Console.WriteLine("High level");
        break;
    }
  }
}
```

Why and When To Use Enums?
* To define a set of named constants (unchangeable/read-only variables) like days of the week, months in a year, etc.

## Namespaces

Namespaces are used to organize code and to avoid name conflicts.

To create a namespace, use the `namespace` keyword.

```csharp
namespace MyNamespace 
{
  class MyClass 
  {
    static void Main(string[] args) 
    {
      Console.WriteLine("Hello World!");
    }
  }
}
```

To access the namespace, use the `using` keyword.

```csharp
using MyNamespace;

namespace MyProgram 
{
  class Program 
  {
    static void Main(string[] args) 
    {
      MyClass myObj = new MyClass();
    }
  }
}
```

## Files

To work with files in C#, you need to include the System.IO namespace.

```csharp
using System.IO;

File.Create("filename.txt");
File.Delete("filename.txt");
File.Exists("filename.txt");
File.Copy("filename.txt", "filename2.txt");
File.Move("filename.txt", "filename2.txt");
File.ReadAllText("filename.txt");
File.WriteAllText("filename.txt", "Hello World");
File.AppendAllText("filename.txt", "Hello World");
File.ReadAllLines("filename.txt");
File.WriteAllLines("filename.txt", new string[] { "Hello", "World" });
File.AppendAllLines("filename.txt", new string[] { "Hello", "World" });
File.Open("filename.txt", FileMode.Open);
```

| Method | Description |
| --- | --- |
| Create | Creates a file |
| Delete | Deletes a file |
| Exists | Checks if a file exists |
| Copy | Copies a file |
| Move | Moves a file |
| ReadAllText | Reads all text from a file |
| WriteAllText | Writes all text to a file |
| AppendText | Appends all text to a file |
| Replace | Replaces the contents of a file with the contents of another file |

Link: https://learn.microsoft.com/en-us/dotnet/api/system.io?view=net-7.0

Write and read a file:

```csharp
using System.IO;

class Program 
{
  static void Main(string[] args) 
  {
    string text = "Hello World";
    File.WriteAllText("filename.txt", text);

    string readText = File.ReadAllText("filename.txt");
    Console.WriteLine(readText);
  }
}
```

## Exceptions

When executing C# code, different errors can occur.

When an error occurs, C# will normally stop and generate an error message. The technical term for this is: C# will throw an exception (throw an error).

### TRY and CATCH

The `try` statement allows you to define a block of code to be tested for errors while it is being executed.

The `catch` statement allows you to define a block of code to be executed, if an error occurs in the try block.

The try and catch keywords come in pairs:

```csharp
try 
{
  // Block of code to try
}
catch (Exception error)
{
  // Block of code to handle errors
}
```

After the try block has been executed, the catch block will be executed, if an error has occurred. The try passes the exception to the catch block as an argument, a built-in object called `Exception`.

```csharp
try 
{
  int[] myNumbers = {1, 2, 3};
  Console.WriteLine(myNumbers[10]);
}
catch (Exception error)
{
  Console.WriteLine(error.Message);
}
```

### Try Catch Finally

The `finally` block lets you execute code, after try...catch, regardless of the result.

```csharp
try 
{
  int[] myNumbers = {1, 2, 3};
  Console.WriteLine(myNumbers[10]);
}
catch (Exception error)
{
  Console.WriteLine(error.Message);
}
finally
{
  Console.WriteLine("The 'try catch' is finished.");
}
```

### Throw keyword

The `throw` keyword is used to create a custom error.

The throw statement is used together with an exception class.

There are many exception classes available in C#: ArithmeticException, FileNotFoundException, IndexOutOfRangeException, TimeOutException, etc...

```csharp
static void CheckAge(int age) 
{
  if (age < 18) 
  {
    throw new ArithmeticException("Access denied - You must be at least 18 years old.");
  }
  else 
  {
    Console.WriteLine("Access granted - You are old enough!");
  }
}

static void Main(string[] args) 
{
  CheckAge(15); // Access denied - You must be at least 18 years old.
}
```

It is a goo practice to throw an exception when an error occurs, and then catch it and handle the error, instead of relying on the default error handling.